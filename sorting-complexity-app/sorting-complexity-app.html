<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms & Big-O Complexity</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #4a5bff;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.1em;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .tab:hover {
            background: #e0e0e0;
            transform: translateY(-2px);
        }
        
        .tab.active {
            background: #4a5bff;
            color: white;
        }
        
        .content {
            display: none;
        }
        
        .content.active {
            display: block;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .complexity-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .complexity-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
        }
        
        .complexity-table tr:hover {
            background: #f5f5f5;
        }
        
        .algo-name {
            background: #4a5bff;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
        }
        
        .best-case { color: #10b981; font-weight: 600; }
        .avg-case { color: #f59e0b; font-weight: 600; }
        .worst-case { color: #ef4444; font-weight: 600; }
        
        .big-o-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .big-o-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .big-o-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border-left: 5px solid #4a5bff;
        }
        
        .big-o-item h3 {
            color: #4a5bff;
            margin-bottom: 10px;
        }
        
        .big-o-item .notation {
            font-size: 1.5em;
            font-weight: bold;
            color: #764ba2;
            margin: 10px 0;
        }
        
        .algo-detail {
            background: #f9fafb;
            padding: 30px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 5px solid #4a5bff;
        }
        
        .algo-detail h2 {
            color: #4a5bff;
            margin-bottom: 15px;
        }
        
        .algo-detail h3 {
            color: #764ba2;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .tutorial-link {
            display: inline-block;
            background: #4a5bff;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .tutorial-link:hover {
            background: #3a4bef;
            transform: translateY(-2px);
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin: 30px 0;
        }
        
        .comparison-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .prompt-section {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin-top: 40px;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        /* Visualization Styles */
        .visualization-container {
            background: #f9fafb;
            padding: 30px;
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            gap: 5px;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
        }
        
        .array-bar {
            flex: 1;
            max-width: 50px;
            background: #4a5bff;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            padding-bottom: 5px;
            border-radius: 4px 4px 0 0;
            transition: all 0.3s;
        }
        
        .array-bar.comparing {
            background: #f59e0b;
        }
        
        .array-bar.swapping {
            background: #ef4444;
        }
        
        .array-bar.sorted {
            background: #10b981;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .btn {
            padding: 12px 24px;
            background: #4a5bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #3a4bef;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: #764ba2;
        }
        
        .btn-secondary:hover {
            background: #653b92;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .speed-control input {
            width: 150px;
        }
        
        /* Code Examples */
        .code-container {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .code-container pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .code-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .code-tab {
            padding: 8px 16px;
            background: #334155;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .code-tab.active {
            background: #4a5bff;
        }
        
        .code-content {
            display: none;
        }
        
        .code-content.active {
            display: block;
        }
        
        /* Quiz Styles */
        .quiz-container {
            background: #f9fafb;
            padding: 30px;
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .quiz-question {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 5px solid #4a5bff;
        }
        
        .quiz-question h3 {
            color: #4a5bff;
            margin-bottom: 15px;
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .quiz-option {
            padding: 15px;
            background: #f0f0f0;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .quiz-option:hover {
            background: #e0e0e0;
            border-color: #4a5bff;
        }
        
        .quiz-option.selected {
            background: #e0e7ff;
            border-color: #4a5bff;
        }
        
        .quiz-option.correct {
            background: #d1fae5;
            border-color: #10b981;
        }
        
        .quiz-option.incorrect {
            background: #fee2e2;
            border-color: #ef4444;
        }
        
        .quiz-feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        .quiz-feedback.show {
            display: block;
        }
        
        .quiz-feedback.correct {
            background: #d1fae5;
            color: #065f46;
        }
        
        .quiz-feedback.incorrect {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .quiz-score {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #4a5bff;
            margin: 20px 0;
        }
        
        .algorithm-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .algo-btn {
            padding: 10px 20px;
            background: #f0f0f0;
            border: 2px solid #4a5bff;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .algo-btn:hover {
            background: #e0e7ff;
        }
        
        .algo-btn.active {
            background: #4a5bff;
            color: white;
        }
        
        .status-text {
            text-align: center;
            font-size: 18px;
            color: #4a5bff;
            margin: 15px 0;
            min-height: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Sorting Algorithms & Big-O Complexity Guide</h1>
        <p class="subtitle">Master algorithm complexity with interactive visualizations, code examples, and quizzes</p>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('overview')">Overview</button>
            <button class="tab" onclick="showTab('sorting')">Sorting Algorithms</button>
            <button class="tab" onclick="showTab('bigo')">Big-O Notation</button>
            <button class="tab" onclick="showTab('visualizer')">Live Visualizer</button>
            <button class="tab" onclick="showTab('code')">Code Examples</button>
            <button class="tab" onclick="showTab('graphs')">Visual Comparisons</button>
            <button class="tab" onclick="showTab('quiz')">Quiz</button>
            <button class="tab" onclick="showTab('details')">Algorithm Details</button>
        </div>
        
        <div id="overview" class="content active">
            <div class="big-o-card">
                <h2>üìä Time Complexity of Sorting Algorithms</h2>
            </div>
            
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best Case</th>
                        <th>Average Case</th>
                        <th>Worst Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="algo-name">Insertion Sort</span></td>
                        <td class="best-case">Œ©(n)</td>
                        <td class="avg-case">Œò(n¬≤)</td>
                        <td class="worst-case">O(n¬≤)</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Selection Sort</span></td>
                        <td class="best-case">Œ©(n¬≤)</td>
                        <td class="avg-case">Œò(n¬≤)</td>
                        <td class="worst-case">O(n¬≤)</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Bubble Sort</span></td>
                        <td class="best-case">Œ©(n)</td>
                        <td class="avg-case">Œò(n¬≤)</td>
                        <td class="worst-case">O(n¬≤)</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Merge Sort</span></td>
                        <td class="best-case">Œ©(n log(n))</td>
                        <td class="avg-case">Œò(n log(n))</td>
                        <td class="worst-case">O(n log(n))</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Quick Sort</span></td>
                        <td class="best-case">Œ©(n log(n))</td>
                        <td class="avg-case">Œò(n log(n))</td>
                        <td class="worst-case">O(n¬≤)</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Heap Sort</span></td>
                        <td class="best-case">Œ©(n log(n))</td>
                        <td class="avg-case">Œò(n log(n))</td>
                        <td class="worst-case">O(n log(n))</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Counting Sort</span></td>
                        <td class="best-case">Œ©(n+k)</td>
                        <td class="avg-case">Œò(n+k)</td>
                        <td class="worst-case">O(n+k)</td>
                    </tr>
                    <tr>
                        <td><span class="algo-name">Radix Sort</span></td>
                        <td class="best-case">Œ©(nk)</td>
                        <td class="avg-case">Œò(nk)</td>
                        <td class="worst-case">O(nk)</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div id="sorting" class="content">
            <h2 style="color: #4a5bff; margin-bottom: 20px;">Sorting Algorithms Explained</h2>
            
            <div class="algo-detail">
                <h2>üî∏ Insertion Sort</h2>
                <p><strong>Simple Explanation:</strong> Like sorting playing cards in your hand - you pick one card at a time and insert it into its correct position among the already sorted cards.</p>
                <p><strong>When to Use:</strong> Small datasets or nearly sorted data. Very efficient for small lists (less than 50 elements).</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/insertion-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/insertion-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
                <a href="https://www.youtube.com/results?search_query=insertion+sort+tutorial" class="tutorial-link" target="_blank">Video Tutorials</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Selection Sort</h2>
                <p><strong>Simple Explanation:</strong> Find the smallest item and move it to the front, then find the next smallest and move it to the second position, and so on.</p>
                <p><strong>When to Use:</strong> When memory writes are expensive (it makes minimum number of swaps). Simple to implement but not efficient for large datasets.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/selection-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/selection-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Bubble Sort</h2>
                <p><strong>Simple Explanation:</strong> Repeatedly step through the list, compare adjacent elements and swap them if they're in the wrong order. The largest elements "bubble" to the end.</p>
                <p><strong>When to Use:</strong> Educational purposes (easy to understand) or when you need to detect if list is already sorted. Not practical for large datasets.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/bubble-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/bubble-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Merge Sort</h2>
                <p><strong>Simple Explanation:</strong> Divide the array into two halves, sort each half, then merge them back together in sorted order. Uses a "divide and conquer" approach.</p>
                <p><strong>When to Use:</strong> Large datasets, linked lists, external sorting. Guarantees O(n log n) performance but requires extra memory.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/merge-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/merge-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Quick Sort</h2>
                <p><strong>Simple Explanation:</strong> Pick a "pivot" element, partition the array so elements smaller than pivot are on left and larger on right, then recursively sort both sides.</p>
                <p><strong>When to Use:</strong> General purpose sorting (often the fastest in practice). Used in many standard libraries. Works in-place with minimal extra memory.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/quick-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/quick-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Heap Sort</h2>
                <p><strong>Simple Explanation:</strong> Build a heap data structure from the array, then repeatedly extract the maximum element and rebuild the heap until sorted.</p>
                <p><strong>When to Use:</strong> When you need guaranteed O(n log n) performance with O(1) space. Good for systems with memory constraints.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/heap-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/heap-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Counting Sort</h2>
                <p><strong>Simple Explanation:</strong> Count how many times each value appears, then use these counts to place elements directly in their final sorted positions.</p>
                <p><strong>When to Use:</strong> When sorting integers within a known, small range (k). Very fast but requires extra space. Not comparison-based.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/counting-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/counting-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
            
            <div class="algo-detail">
                <h2>üî∏ Radix Sort</h2>
                <p><strong>Simple Explanation:</strong> Sort numbers digit by digit, starting from the least significant digit to the most significant digit.</p>
                <p><strong>When to Use:</strong> Sorting integers or strings of fixed length. Can be faster than comparison sorts for certain data types.</p>
                <p><strong>Tutorials:</strong></p>
                <a href="https://www.geeksforgeeks.org/radix-sort/" class="tutorial-link" target="_blank">GeeksforGeeks Tutorial</a>
                <a href="https://www.programiz.com/dsa/radix-sort" class="tutorial-link" target="_blank">Programiz Guide</a>
            </div>
        </div>
        
        <div id="bigo" class="content">
            <div class="big-o-card">
                <h2>üìê Big-O Notation Cheat Sheet</h2>
                <p>Understanding algorithm efficiency and growth rates</p>
            </div>
            
            <div class="big-o-grid">
                <div class="big-o-item">
                    <h3>Constant Time</h3>
                    <div class="notation">O(1)</div>
                    <p><strong>Description:</strong> Execution time remains unchanged irrespective of input data size.</p>
                    <p><strong>Example:</strong> Checking if a stack is empty, accessing an array element by index.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Logarithmic Time</h3>
                    <div class="notation">O(log n)</div>
                    <p><strong>Description:</strong> Complexity increases by one unit for each doubling of input data.</p>
                    <p><strong>Example:</strong> Finding an item in a balanced search tree, binary search.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Linear Time</h3>
                    <div class="notation">O(n)</div>
                    <p><strong>Description:</strong> Execution time increases linearly with the size of the input data.</p>
                    <p><strong>Example:</strong> Linear traversal of a list, simple search in an unsorted array.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Log-Linear Time</h3>
                    <div class="notation">O(n log n)</div>
                    <p><strong>Description:</strong> Complexity grows as a combination of linear and logarithmic.</p>
                    <p><strong>Example:</strong> Merge sort on a collection of items, efficient sorting algorithms.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Quadratic Time</h3>
                    <div class="notation">O(n¬≤)</div>
                    <p><strong>Description:</strong> Time taken is proportional to the square of the number of elements.</p>
                    <p><strong>Example:</strong> Checking all possible pairs in an array, nested loops.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Cubic Time</h3>
                    <div class="notation">O(n¬≥)</div>
                    <p><strong>Description:</strong> Execution time is proportional to the cube of the number of elements.</p>
                    <p><strong>Example:</strong> Matrix multiplication of n x n matrices.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Exponential Time</h3>
                    <div class="notation">O(2‚Åø)</div>
                    <p><strong>Description:</strong> Time doubles for every new element added.</p>
                    <p><strong>Example:</strong> Generating all subsets of a given set, recursive Fibonacci.</p>
                </div>
                
                <div class="big-o-item">
                    <h3>Factorial Time</h3>
                    <div class="notation">O(n!)</div>
                    <p><strong>Description:</strong> Complexity grows factorially based on the size of the dataset.</p>
                    <p><strong>Example:</strong> Determining all permutations of a given list, traveling salesman problem.</p>
                </div>
            </div>
        </div>
        
        <div id="visualizer" class="content">
            <h2 style="color: #4a5bff; margin-bottom: 20px;">Interactive Sorting Visualizer</h2>
            
            <div class="visualization-container">
                <h3>Select Algorithm:</h3>
                <div class="algorithm-selector">
                    <button class="algo-btn active" onclick="selectAlgorithm('bubble')">Bubble Sort</button>
                    <button class="algo-btn" onclick="selectAlgorithm('insertion')">Insertion Sort</button>
                    <button class="algo-btn" onclick="selectAlgorithm('selection')">Selection Sort</button>
                    <button class="algo-btn" onclick="selectAlgorithm('merge')">Merge Sort</button>
                    <button class="algo-btn" onclick="selectAlgorithm('quick')">Quick Sort</button>
                </div>
                
                <div class="status-text" id="statusText">Click "Start Sort" to begin</div>
                
                <div class="array-container" id="arrayContainer"></div>
                
                <div class="controls">
                    <button class="btn" onclick="startSort()" id="startBtn">Start Sort</button>
                    <button class="btn" onclick="pauseSort()" id="pauseBtn" disabled>Pause</button>
                    <button class="btn btn-secondary" onclick="resetArray()">Generate New Array</button>
                    <div class="speed-control">
                        <label>Speed:</label>
                        <input type="range" id="speedSlider" min="10" max="500" value="100" oninput="updateSpeed()">
                        <span id="speedValue">100ms</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="code" class="content">
            <h2 style="color: #4a5bff; margin-bottom: 20px;">Code Examples</h2>
            
            <div class="algo-detail">
                <h2>Bubble Sort</h2>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="showCode('bubble', 'js')">JavaScript</button>
                    <button class="code-tab" onclick="showCode('bubble', 'python')">Python</button>
                    <button class="code-tab" onclick="showCode('bubble', 'java')">Java</button>
                </div>
                <div class="code-container">
                    <div id="bubble-js" class="code-content active">
<pre>function bubbleSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}</pre>
                    </div>
                    <div id="bubble-python" class="code-content">
<pre>def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                # Swap elements
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    
    return arr</pre>
                    </div>
                    <div id="bubble-java" class="code-content">
<pre>public static void bubbleSort(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}</pre>
                    </div>
                </div>
            </div>
            
            <div class="algo-detail">
                <h2>Insertion Sort</h2>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="showCode('insertion', 'js')">JavaScript</button>
                    <button class="code-tab" onclick="showCode('insertion', 'python')">Python</button>
                    <button class="code-tab" onclick="showCode('insertion', 'java')">Java</button>
                </div>
                <div class="code-container">
                    <div id="insertion-js" class="code-content active">
<pre>function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}</pre>
                    </div>
                    <div id="insertion-python" class="code-content">
<pre>def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr</pre>
                    </div>
                    <div id="insertion-java" class="code-content">
<pre>public static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}</pre>
                    </div>
                </div>
            </div>
            
            <div class="algo-detail">
                <h2>Selection Sort</h2>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="showCode('selection', 'js')">JavaScript</button>
                    <button class="code-tab" onclick="showCode('selection', 'python')">Python</button>
                    <button class="code-tab" onclick="showCode('selection', 'java')">Java</button>
                </div>
                <div class="code-container">
                    <div id="selection-js" class="code-content active">
<pre>function selectionSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        let minIdx = i;
        
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        if (minIdx !== i) {
            [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
        }
    }
    return arr;
}</pre>
                    </div>
                    <div id="selection-python" class="code-content">
<pre>def selection_sort(arr):
    for i in range(len(arr) - 1):
        min_idx = i
        
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr</pre>
                    </div>
                    <div id="selection-java" class="code-content">
<pre>public static void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIdx = i;
        
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        if (minIdx != i) {
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
        }
    }
}</pre>
                    </div>
                </div>
            </div>
            
            <div class="algo-detail">
                <h2>Merge Sort</h2>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="showCode('merge', 'js')">JavaScript</button>
                    <button class="code-tab" onclick="showCode('merge', 'python')">Python</button>
                    <button class="code-tab" onclick="showCode('merge', 'java')">Java</button>
                </div>
                <div class="code-container">
                    <div id="merge-js" class="code-content active">
<pre>function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}</pre>
                    </div>
                    <div id="merge-python" class="code-content">
<pre>def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result</pre>
                    </div>
                    <div id="merge-java" class="code-content">
<pre>public static void mergeSort(int[] arr, int l, int r) {
    if (l < r) {
        int mid = l + (r - l) / 2;
        
        mergeSort(arr, l, mid);
        mergeSort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }
}

private static void merge(int[] arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    
    int[] L = new int[n1];
    int[] R = new int[n2];
    
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
    
    int i = 0, j = 0, k = l;
    
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }
    
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}</pre>
                    </div>
                </div>
            </div>
            
            <div class="algo-detail">
                <h2>Quick Sort</h2>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="showCode('quick', 'js')">JavaScript</button>
                    <button class="code-tab" onclick="showCode('quick', 'python')">Python</button>
                    <button class="code-tab" onclick="showCode('quick', 'java')">Java</button>
                </div>
                <div class="code-container">
                    <div id="quick-js" class="code-content active">
<pre>function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}</pre>
                    </div>
                    <div id="quick-python" class="code-content">
<pre>def quick_sort(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)
    
    return arr

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1</pre>
                    </div>
                    <div id="quick-java" class="code-content">
<pre>public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    return i + 1;
}</pre>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="graphs" class="content">
            <h2 style="color: #4a5bff; margin-bottom: 20px;">Visual Complexity Comparisons</h2>
            
            <div class="comparison-section">
                <h3>Sorting Algorithms Performance Comparison</h3>
                <div class="chart-container">
                    <canvas id="sortingChart"></canvas>
                </div>
            </div>
            
            <div class="comparison-section">
                <h3>Big-O Complexity Growth Rates</h3>
                <div class="chart-container">
                    <canvas id="bigOChart"></canvas>
                </div>
            </div>
            
            <div class="comparison-section">
                <h3>Average Case Performance (Bar Chart)</h3>
                <div class="chart-container">
                    <canvas id="barChart"></canvas>
                </div>
            </div>
        </div>
        
        <div id="quiz" class="content">
            <h2 style="color: #4a5bff; margin-bottom: 20px;">Test Your Knowledge</h2>
            <div class="quiz-score" id="quizScore">Score: 0 / 0</div>
            
            <div class="quiz-container" id="quizContainer">
                <!-- Quiz questions will be dynamically generated -->
            </div>
            
            <div class="controls">
                <button class="btn" onclick="checkAnswers()">Check Answers</button>
                <button class="btn btn-secondary" onclick="resetQuiz()">Reset Quiz</button>
            </div>
        </div>
        
        <div id="details" class="content">
            <h2 style="color: #4a5bff; margin-bottom: 20px;">Detailed Algorithm Analysis</h2>
            
            <div class="algo-detail">
                <h2>üéØ Choosing the Right Algorithm</h2>
                <h3>For Small Datasets (n < 50):</h3>
                <p>‚úÖ <strong>Insertion Sort</strong> - Simple and efficient for small data</p>
                
                <h3>For Nearly Sorted Data:</h3>
                <p>‚úÖ <strong>Insertion Sort</strong> or <strong>Bubble Sort</strong> - Can achieve O(n) performance</p>
                
                <h3>For General Purpose (Large Datasets):</h3>
                <p>‚úÖ <strong>Quick Sort</strong> - Fastest average case, in-place sorting</p>
                <p>‚úÖ <strong>Merge Sort</strong> - Stable sort, guaranteed O(n log n), good for linked lists</p>
                
                <h3>For Guaranteed Performance:</h3>
                <p>‚úÖ <strong>Heap Sort</strong> or <strong>Merge Sort</strong> - Always O(n log n), no worst case O(n¬≤)</p>
                
                <h3>For Integer Sorting with Limited Range:</h3>
                <p>‚úÖ <strong>Counting Sort</strong> or <strong>Radix Sort</strong> - Can beat O(n log n) barrier</p>
                
                <h3>For Memory-Constrained Systems:</h3>
                <p>‚úÖ <strong>Heap Sort</strong> or <strong>Quick Sort</strong> - In-place sorting with O(1) or O(log n) space</p>
            </div>
            
            <div class="algo-detail">
                <h2>üìä Space Complexity Comparison</h2>
                <ul style="list-style-position: inside; line-height: 2;">
                    <li><strong>O(1) Space:</strong> Insertion Sort, Selection Sort, Bubble Sort, Heap Sort</li>
                    <li><strong>O(log n) Space:</strong> Quick Sort (recursive stack)</li>
                    <li><strong>O(n) Space:</strong> Merge Sort</li>
                    <li><strong>O(n+k) Space:</strong> Counting Sort</li>
                    <li><strong>O(n+k) Space:</strong> Radix Sort</li>
                </ul>
            </div>
            
            <div class="algo-detail">
                <h2>üîÑ Stability in Sorting</h2>
                <p><strong>Stable sorts</strong> preserve the relative order of equal elements:</p>
                <p>‚úÖ <strong>Stable:</strong> Insertion Sort, Merge Sort, Bubble Sort, Counting Sort, Radix Sort</p>
                <p>‚ùå <strong>Unstable:</strong> Selection Sort, Quick Sort, Heap Sort</p>
            </div>
            
            <div class="algo-detail">
                <h2>‚ö° Performance Characteristics</h2>
                <table class="complexity-table">
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                            <th>Stable</th>
                            <th>In-Place</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Insertion Sort</strong></td>
                            <td>O(n¬≤)</td>
                            <td>O(1)</td>
                            <td>‚úÖ Yes</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Selection Sort</strong></td>
                            <td>O(n¬≤)</td>
                            <td>O(1)</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Bubble Sort</strong></td>
                            <td>O(n¬≤)</td>
                            <td>O(1)</td>
                            <td>‚úÖ Yes</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Merge Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                            <td>‚úÖ Yes</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td><strong>Quick Sort</strong></td>
                            <td>O(n log n) avg</td>
                            <td>O(log n)</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Heap Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="prompt-section">
            <h3 style="color: #4a5bff; margin-bottom: 15px;">Original Prompt</h3>
            <p>Create app in HTML/JavaScript compiling the information in the graphics. Include descriptions of each algorithm in simple language and how it is used. Use URLs for tutorials. Ask questions interactively if something is not needed. Include graphs for each algorithm. Include the graphics and include the prompt at the end.</p>
        </div>
    </div>

    <script>
        // Global variables
        let sortArray = [];
        let sortSpeed = 100;
        let sorting = false;
        let paused = false;
        let currentAlgorithm = 'bubble';
        let quizAnswers = {};
        let quizScore = { correct: 0, total: 0 };
        
        // Tab Management - Define globally first
        window.showTab = function(tabName) {
            const contents = document.querySelectorAll('.content');
            const tabs = document.querySelectorAll('.tab');
            
            contents.forEach(content => content.classList.remove('active'));
            tabs.forEach(tab => tab.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            if (tabName === 'graphs') {
                setTimeout(initCharts, 100);
            }
        };
        
        // Code Tab Management
        window.showCode = function(algo, lang) {
            const tabs = event.target.parentElement.querySelectorAll('.code-tab');
            const contents = event.target.parentElement.nextElementSibling.querySelectorAll('.code-content');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${algo}-${lang}`).classList.add('active');
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            generateArray();
            initQuiz();
        });
        function generateArray() {
            sortArray = [];
            for (let i = 0; i < 15; i++) {
                sortArray.push(Math.floor(Math.random() * 90) + 10);
            }
            renderArray();
        }
        
        function renderArray(comparing = [], swapping = [], sorted = []) {
            const container = document.getElementById('arrayContainer');
            container.innerHTML = '';
            
            sortArray.forEach((value, idx) => {
                const bar = document.createElement('div');
                bar.className = 'array-bar';
                bar.style.height = `${value * 2.5}px`;
                bar.textContent = value;
                
                if (sorted.includes(idx)) {
                    bar.classList.add('sorted');
                } else if (swapping.includes(idx)) {
                    bar.classList.add('swapping');
                } else if (comparing.includes(idx)) {
                    bar.classList.add('comparing');
                }
                
                container.appendChild(bar);
            });
        }
        
        function selectAlgorithm(algo) {
            if (sorting) return;
            
            currentAlgorithm = algo;
            const buttons = document.querySelectorAll('.algo-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        function updateSpeed() {
            sortSpeed = document.getElementById('speedSlider').value;
            document.getElementById('speedValue').textContent = sortSpeed + 'ms';
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }
        
        async function startSort() {
            if (sorting) return;
            
            sorting = true;
            paused = false;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            
            switch(currentAlgorithm) {
                case 'bubble':
                    await bubbleSort();
                    break;
                case 'insertion':
                    await insertionSort();
                    break;
                case 'selection':
                    await selectionSort();
                    break;
                case 'merge':
                    await mergeSortWrapper();
                    break;
                case 'quick':
                    await quickSortWrapper();
                    break;
            }
            
            sorting = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            updateStatus('Sorting Complete! ‚úÖ');
        }
        
        function pauseSort() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
            updateStatus(paused ? 'Paused ‚è∏Ô∏è' : 'Sorting...');
        }
        
        function resetArray() {
            if (sorting) return;
            generateArray();
            updateStatus('Click "Start Sort" to begin');
        }
        
        async function bubbleSort() {
            const n = sortArray.length;
            updateStatus('Bubble Sort: Comparing adjacent elements...');
            
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    while (paused) await sleep(100);
                    
                    renderArray([j, j + 1], [], []);
                    await sleep(sortSpeed);
                    
                    if (sortArray[j] > sortArray[j + 1]) {
                        renderArray([], [j, j + 1], []);
                        [sortArray[j], sortArray[j + 1]] = [sortArray[j + 1], sortArray[j]];
                        await sleep(sortSpeed);
                    }
                }
                renderArray([], [], Array.from({length: n - i}, (_, k) => n - 1 - k));
            }
            
            renderArray([], [], Array.from({length: n}, (_, k) => k));
        }
        
        async function insertionSort() {
            const n = sortArray.length;
            updateStatus('Insertion Sort: Inserting elements into sorted position...');
            
            for (let i = 1; i < n; i++) {
                let key = sortArray[i];
                let j = i - 1;
                
                while (paused) await sleep(100);
                renderArray([i], [], []);
                await sleep(sortSpeed);
                
                while (j >= 0 && sortArray[j] > key) {
                    while (paused) await sleep(100);
                    
                    renderArray([j, j + 1], [], []);
                    sortArray[j + 1] = sortArray[j];
                    await sleep(sortSpeed);
                    j--;
                }
                sortArray[j + 1] = key;
                renderArray([], [], []);
            }
            
            renderArray([], [], Array.from({length: n}, (_, k) => k));
        }
        
        async function selectionSort() {
            const n = sortArray.length;
            updateStatus('Selection Sort: Finding minimum and placing it...');
            
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                
                for (let j = i + 1; j < n; j++) {
                    while (paused) await sleep(100);
                    
                    renderArray([j, minIdx], [], Array.from({length: i}, (_, k) => k));
                    await sleep(sortSpeed);
                    
                    if (sortArray[j] < sortArray[minIdx]) {
                        minIdx = j;
                    }
                }
                
                if (minIdx !== i) {
                    renderArray([], [i, minIdx], Array.from({length: i}, (_, k) => k));
                    [sortArray[i], sortArray[minIdx]] = [sortArray[minIdx], sortArray[i]];
                    await sleep(sortSpeed);
                }
                
                renderArray([], [], Array.from({length: i + 1}, (_, k) => k));
            }
            
            renderArray([], [], Array.from({length: n}, (_, k) => k));
        }
        
        async function mergeSortWrapper() {
            updateStatus('Merge Sort: Dividing and merging...');
            await mergeSort(0, sortArray.length - 1);
            renderArray([], [], Array.from({length: sortArray.length}, (_, k) => k));
        }
        
        async function mergeSort(left, right) {
            if (left < right) {
                const mid = Math.floor((left + right) / 2);
                await mergeSort(left, mid);
                await mergeSort(mid + 1, right);
                await merge(left, mid, right);
            }
        }
        
        async function merge(left, mid, right) {
            const leftArr = sortArray.slice(left, mid + 1);
            const rightArr = sortArray.slice(mid + 1, right + 1);
            
            let i = 0, j = 0, k = left;
            
            while (i < leftArr.length && j < rightArr.length) {
                while (paused) await sleep(100);
                
                renderArray([k], [], []);
                await sleep(sortSpeed);
                
                if (leftArr[i] <= rightArr[j]) {
                    sortArray[k] = leftArr[i];
                    i++;
                } else {
                    sortArray[k] = rightArr[j];
                    j++;
                }
                k++;
            }
            
            while (i < leftArr.length) {
                while (paused) await sleep(100);
                sortArray[k] = leftArr[i];
                renderArray([k], [], []);
                await sleep(sortSpeed);
                i++;
                k++;
            }
            
            while (j < rightArr.length) {
                while (paused) await sleep(100);
                sortArray[k] = rightArr[j];
                renderArray([k], [], []);
                await sleep(sortSpeed);
                j++;
                k++;
            }
        }
        
        async function quickSortWrapper() {
            updateStatus('Quick Sort: Partitioning around pivot...');
            await quickSort(0, sortArray.length - 1);
            renderArray([], [], Array.from({length: sortArray.length}, (_, k) => k));
        }
        
        async function quickSort(low, high) {
            if (low < high) {
                const pi = await partition(low, high);
                await quickSort(low, pi - 1);
                await quickSort(pi + 1, high);
            }
        }
        
        async function partition(low, high) {
            const pivot = sortArray[high];
            let i = low - 1;
            
            for (let j = low; j < high; j++) {
                while (paused) await sleep(100);
                
                renderArray([j, high], [], []);
                await sleep(sortSpeed);
                
                if (sortArray[j] < pivot) {
                    i++;
                    renderArray([], [i, j], []);
                    [sortArray[i], sortArray[j]] = [sortArray[j], sortArray[i]];
                    await sleep(sortSpeed);
                }
            }
            
            renderArray([], [i + 1, high], []);
            [sortArray[i + 1], sortArray[high]] = [sortArray[high], sortArray[i + 1]];
            await sleep(sortSpeed);
            
            return i + 1;
        }
        
        // Charts Initialization
        function initCharts() {
            const ctx1 = document.getElementById('sortingChart');
            if (ctx1 && !ctx1.chart) {
                const sizes = [10, 50, 100, 500, 1000, 5000];
                
                ctx1.chart = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: sizes,
                        datasets: [
                            {
                                label: 'Insertion Sort O(n¬≤)',
                                data: sizes.map(n => n * n),
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                tension: 0.4
                            },
                            {
                                label: 'Merge Sort O(n log n)',
                                data: sizes.map(n => n * Math.log2(n)),
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                tension: 0.4
                            },
                            {
                                label: 'Quick Sort O(n log n)',
                                data: sizes.map(n => n * Math.log2(n)),
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.4
                            },
                            {
                                label: 'Bubble Sort O(n¬≤)',
                                data: sizes.map(n => n * n),
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Operations vs Input Size',
                                font: { size: 16 }
                            },
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Operations'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Input Size (n)'
                                }
                            }
                        }
                    }
                });
            }
            
            const ctx2 = document.getElementById('bigOChart');
            if (ctx2 && !ctx2.chart) {
                const n = [1, 2, 4, 8, 16, 32, 64];
                
                ctx2.chart = new Chart(ctx2, {
                    type: 'line',
                    data: {
                        labels: n,
                        datasets: [
                            {
                                label: 'O(1) Constant',
                                data: n.map(() => 1),
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)'
                            },
                            {
                                label: 'O(log n) Logarithmic',
                                data: n.map(x => Math.log2(x)),
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)'
                            },
                            {
                                label: 'O(n) Linear',
                                data: n,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)'
                            },
                            {
                                label: 'O(n log n) Log-Linear',
                                data: n.map(x => x * Math.log2(x)),
                                borderColor: '#8b5cf6',
                                backgroundColor: 'rgba(139, 92, 246, 0.1)'
                            },
                            {
                                label: 'O(n¬≤) Quadratic',
                                data: n.map(x => x * x),
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)'
                            },
                            {
                                label: 'O(2‚Åø) Exponential',
                                data: n.slice(0, 5).map(x => Math.pow(2, x)),
                                borderColor: '#dc2626',
                                backgroundColor: 'rgba(220, 38, 38, 0.1)'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Big-O Growth Rates Comparison',
                                font: { size: 16 }
                            },
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Operations (log scale)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Input Size (n)'
                                }
                            }
                        }
                    }
                });
            }
            
            const ctx3 = document.getElementById('barChart');
            if (ctx3 && !ctx3.chart) {
                ctx3.chart = new Chart(ctx3, {
                    type: 'bar',
                    data: {
                        labels: ['Insertion', 'Selection', 'Bubble', 'Merge', 'Quick', 'Heap', 'Counting', 'Radix'],
                        datasets: [{
                            label: 'Average Case Complexity (relative)',
                            data: [100, 100, 100, 30, 30, 30, 20, 20],
                            backgroundColor: [
                                'rgba(239, 68, 68, 0.8)',
                                'rgba(239, 68, 68, 0.8)',
                                'rgba(239, 68, 68, 0.8)',
                                'rgba(16, 185, 129, 0.8)',
                                'rgba(16, 185, 129, 0.8)',
                                'rgba(16, 185, 129, 0.8)',
                                'rgba(59, 130, 246, 0.8)',
                                'rgba(59, 130, 246, 0.8)'
                            ],
                            borderColor: [
                                '#ef4444',
                                '#ef4444',
                                '#ef4444',
                                '#10b981',
                                '#10b981',
                                '#10b981',
                                '#3b82f6',
                                '#3b82f6'
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Average Case Performance (Lower is Better)',
                                font: { size: 16 }
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Relative Time Units'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Algorithm'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Quiz Functions
        const quizQuestions = [
            {
                id: 1,
                question: "Which sorting algorithm has the best average-case time complexity?",
                options: [
                    "Bubble Sort",
                    "Insertion Sort",
                    "Merge Sort",
                    "Selection Sort"
                ],
                correct: 2,
                explanation: "Merge Sort has O(n log n) average-case complexity, which is better than the O(n¬≤) complexity of Bubble, Insertion, and Selection sorts."
            },
            {
                id: 2,
                question: "Which algorithm is most suitable for nearly sorted data?",
                options: [
                    "Quick Sort",
                    "Merge Sort",
                    "Insertion Sort",
                    "Heap Sort"
                ],
                correct: 2,
                explanation: "Insertion Sort performs excellently on nearly sorted data, achieving O(n) time complexity in the best case."
            },
            {
                id: 3,
                question: "What is the space complexity of Merge Sort?",
                options: [
                    "O(1)",
                    "O(log n)",
                    "O(n)",
                    "O(n¬≤)"
                ],
                correct: 2,
                explanation: "Merge Sort requires O(n) extra space to store the temporary arrays during the merge process."
            },
            {
                id: 4,
                question: "Which sorting algorithm is NOT stable?",
                options: [
                    "Merge Sort",
                    "Insertion Sort",
                    "Quick Sort",
                    "Bubble Sort"
                ],
                correct: 2,
                explanation: "Quick Sort is not stable by default, meaning it may change the relative order of equal elements."
            },
            {
                id: 5,
                question: "What is the worst-case time complexity of Quick Sort?",
                options: [
                    "O(n)",
                    "O(n log n)",
                    "O(n¬≤)",
                    "O(log n)"
                ],
                correct: 2,
                explanation: "Quick Sort has a worst-case time complexity of O(n¬≤), which occurs when the pivot selection is poor (e.g., already sorted array with first element as pivot)."
            },
            {
                id: 6,
                question: "Which Big-O notation represents constant time?",
                options: [
                    "O(n)",
                    "O(log n)",
                    "O(1)",
                    "O(n¬≤)"
                ],
                correct: 2,
                explanation: "O(1) represents constant time, meaning the execution time doesn't change with input size."
            },
            {
                id: 7,
                question: "Which algorithm always takes O(n¬≤) time regardless of input?",
                options: [
                    "Bubble Sort",
                    "Insertion Sort",
                    "Selection Sort",
                    "Merge Sort"
                ],
                correct: 2,
                explanation: "Selection Sort always performs O(n¬≤) comparisons regardless of whether the array is sorted or not."
            },
            {
                id: 8,
                question: "What does 'in-place' sorting mean?",
                options: [
                    "The algorithm sorts in O(1) time",
                    "The algorithm uses O(1) extra space",
                    "The algorithm is stable",
                    "The algorithm uses recursion"
                ],
                correct: 1,
                explanation: "In-place sorting means the algorithm requires only O(1) extra space beyond the input array."
            }
        ];
        
        function initQuiz() {
            const container = document.getElementById('quizContainer');
            container.innerHTML = '';
            quizAnswers = {};
            
            quizQuestions.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'quiz-question';
                questionDiv.innerHTML = `
                    <h3>Question ${index + 1}</h3>
                    <p>${q.question}</p>
                    <div class="quiz-options">
                        ${q.options.map((option, optIndex) => `
                            <div class="quiz-option" onclick="selectAnswer(${q.id}, ${optIndex})">
                                ${option}
                            </div>
                        `).join('')}
                    </div>
                    <div class="quiz-feedback" id="feedback-${q.id}">
                        <strong>Explanation:</strong> ${q.explanation}
                    </div>
                `;
                container.appendChild(questionDiv);
            });
        }
        
        function selectAnswer(questionId, answerIndex) {
            const question = quizQuestions.find(q => q.id === questionId);
            const options = document.querySelectorAll(`#quizContainer .quiz-question:nth-child(${questionId}) .quiz-option`);
            
            options.forEach(opt => opt.classList.remove('selected'));
            options[answerIndex].classList.add('selected');
            
            quizAnswers[questionId] = answerIndex;
        }
        
        function checkAnswers() {
            let correct = 0;
            let total = quizQuestions.length;
            
            quizQuestions.forEach((q, index) => {
                const userAnswer = quizAnswers[q.id];
                const options = document.querySelectorAll(`#quizContainer .quiz-question:nth-child(${index + 1}) .quiz-option`);
                const feedback = document.getElementById(`feedback-${q.id}`);
                
                options.forEach((opt, optIndex) => {
                    opt.classList.remove('correct', 'incorrect');
                    if (optIndex === q.correct) {
                        opt.classList.add('correct');
                    } else if (optIndex === userAnswer && userAnswer !== q.correct) {
                        opt.classList.add('incorrect');
                    }
                });
                
                feedback.classList.add('show');
                if (userAnswer === q.correct) {
                    feedback.classList.add('correct');
                    feedback.classList.remove('incorrect');
                    correct++;
                } else {
                    feedback.classList.add('incorrect');
                    feedback.classList.remove('correct');
                }
            });
            
            document.getElementById('quizScore').textContent = `Score: ${correct} / ${total} (${Math.round(correct/total*100)}%)`;
        }
        
        function resetQuiz() {
            initQuiz();
            document.getElementById('quizScore').textContent = 'Score: 0 / 0';
        }
    </script>
</body>
</html>
            